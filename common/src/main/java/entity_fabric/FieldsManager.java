package entity_fabric;

import entity_fabric.data_providers.EntityDataProvider;
import entity_fabric.data_providers.IntegerDataProvider;
import entity_fabric.data_providers.StringDataProvider;
import entity_fabric.data_providers.UserDefinedDataProvider;
import entity_fabric.entity_fields_annotations.DataProvider;
import entity_fabric.entity_fields_annotations.Required;
import error_reporter.ErrorReporter;
import org.apache.commons.beanutils.BeanUtils;
import org.apache.log4j.Logger;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.List;


class FieldsManager<T> {
    
    private T teelaInstance;
    private Logger logger = Logger.getLogger(FieldsManager.class);
    private FieldAttributeManager attributeManager = new FieldAttributeManager();
    
    FieldsManager(T teelaInstance) {
        this.teelaInstance = teelaInstance;
    }
    
    
    /**
     * Returns list of fields that are marked as required.
     * @return list of required fields.
     */
    List<Field> getInstanceRequiredFields() {
        logger.debug("Getting required fields for instance:"+teelaInstance);
        Field[] fields = teelaInstance.getClass().getDeclaredFields();
        List<Field> requiredOnlyFields = new ArrayList<>();
        for (Field field : fields) {
            if (attributeManager.isFieldRequired(field)) {
                requiredOnlyFields.add(field);
            }
        }
        logger.debug("Required fields are:"+requiredOnlyFields);
        return requiredOnlyFields;
        
    }
    
    /**
     * Fills the field with data that is generated by {@link FieldDataGenerator} that
     * is received either from annotation {@link DataProvider} or based on field's data
     * type. If any error occurred, field will be initialized with null.
     * @param field {@link Field} of the Entity to fill in.
     */
    void fillField(Field field) {
        logger.debug("Filling field " + field.getName());
        FieldDataGenerator selectedDataProvider = attributeManager.getFieldDataGenerator(field);
        Object data = selectedDataProvider.generateData();
        try {
            BeanUtils.setProperty(teelaInstance, field.getName(), data);
        } catch (IllegalAccessException | InvocationTargetException e) {
            ErrorReporter.reportError(e);
            logger.warn(String.format("Was unable to set value %s for field:%s", data, field.getName()));
        }
    }
    
    /**
     * Private inner class of FieldsManager.
     * Is used to get attributes of field: required and {@link FieldDataGenerator}
     * based on provided {@link DataProvider} or field's type.
     */
    
    private class FieldAttributeManager {
        
        /**
         * Returns true if field is marked with annotation {@link Required}
         * @param field {@link Field} to read presence of annotation from.
         * @return Boolean if field is marked as Required. Empty collection
         * is returned if there are not any.
         */
        private Boolean isFieldRequired(Field field) {
            return field.isAnnotationPresent(Required.class);
        }
    
    
        /**
         * Returns {@link FieldDataGenerator object} that is assigned to the field.
         * This object further will be used to generate random value for the field.
          * @param field {@link Field} object to get {@link FieldDataGenerator} for.
         * @return {@link FieldDataGenerator} object.
         */
        private FieldDataGenerator getFieldDataGenerator(Field field) {
            FieldDataGenerator generatorFromAnnatation = getAnnotatedDataGenerator(field);
            FieldDataGenerator selectedDataGenerator;
            if (generatorFromAnnatation == null) {
                selectedDataGenerator = getFieldGeneratorTypeBased(field);
            } else {
                selectedDataGenerator = generatorFromAnnatation;
            }
            return  selectedDataGenerator;
            
        }
    
        /**
         * Internal method of FieldAttributeManager class. Gets {@link FieldDataGenerator}
         * instance based on field type.
         * @return {@link FieldDataGenerator}
         */
        private FieldDataGenerator getFieldGeneratorTypeBased(Field field) {
            Class<?> fieldType =  field.getType();
            EntityDataProvider dataProvider;
            if (fieldType.equals(Integer.class)) {
                dataProvider = new IntegerDataProvider();
            } else if (fieldType.equals(String.class)) {
                dataProvider = new StringDataProvider();
            } else {
                dataProvider = new UserDefinedDataProvider(fieldType);
            }
            return new FieldDataGenerator(dataProvider, EntityDataProvider.dataLength);
        }
    
        /**
         * Internal method of FieldAttributeManager class. Gets data generator instance if
         * annotation DataProvider is defined for a field. Otherwise null is returned.
         * @return {@link FieldDataGenerator} instance or null if no DataProvider defined.
         */
        private FieldDataGenerator getAnnotatedDataGenerator(Field field) {
            logger.debug("Reading field " + field.getName()+" annotations");
            boolean dataProviderAnnotationDefined = field.isAnnotationPresent(DataProvider.class);
            if (!dataProviderAnnotationDefined) {
                logger.debug("Field doesn't have Data Provider annotation");
                return null;
            }
            Annotation annotation = field.getAnnotation(DataProvider.class);
            DataProvider dataProvider = (DataProvider) annotation;
            Class<? extends EntityDataProvider> dataProviderClass = dataProvider.providerClass();
            try {
                EntityDataProvider entityDataProvider =  dataProviderClass.newInstance();
                int dataLength = dataProvider.length();
                return new FieldDataGenerator(entityDataProvider, dataLength);
            } catch (InstantiationException | IllegalAccessException e) {
                ErrorReporter.reportError(e);
                logger.debug("cannot create instance of Data Provider by class:" + dataProviderClass
                        + "Null will be returned");
                return null;
            
            }
        }
        
        
        
    }
    
    
    
}
